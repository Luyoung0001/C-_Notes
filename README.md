# Cpp_Notes For the book C++ Primer Plus
## 1. notes and samples of codes for learning C++
## 2. notes are from WeRead below(updates from time to time):

《C++ Primer Plus（第6版）中文版》

[美] Stephen Prata
932个笔记

## 第1章 预备知识

◆ 它不是将重点放在任务上，而是放在表示概念上。

◆ 而泛型编程提供了执行常见任务（如对数据排序或合并链表）的工具

◆ C++融合了OOP、泛型编程和传统的过程性方法，这表明C++强调的是实用价值，而不是意识形态方法，这也是该语言获得成功的原因之一。

◆ 于C++03没有改变语言特性，因此我们使用C++98表示C++98/C++2003。

◆ 实际上，ANSI C加入了C++首次引入的一些特性，如函数原型和类型限定符const。


## 第2章 开始学习C++

◆ 然而，通常，main( )被启动代码调用，而启动代码是由编译器添加到程序中的，是程序和操作系统（UNIX、Windows 7或其他操作系统）之间的桥梁。事实上，该函数头描述的是main( )和操作系统之间的接口。

◆ 如果编译器到达main( )函数末尾时没有遇到返回语句，则认为main( )函数以如下语句结尾：

◆ 本书中显示用引号括起的字符串时，通常使用换行符\n，在其他情况下则使用控制符endl。一个差别是，endl确保程序继续运行前刷新输出（将其立即显示在屏幕上）；而使用“\n”不能提供这样的保证，这意味着在有些系统中，有时可能在您输入信息后才会出现提示。

◆ 每条语句占一行。

◆ 它是一个ostream类对象。ostream类定义（iostream文件的另一个成员）描述了ostream对象表示的数据以及可以对它执行的操作，如将数字或字符串插入到输出流中。

◆ C++提供了两种发送消息的方式：一种方式是使用类方法（本质上就是稍后将介绍的函数调用）；另一种方式是重新定义运算符，cin和cout采用的就是这种方式。

◆ C++程序应当为程序中使用的每个函数提供原型

◆ 像变量声明

◆ 第二种方法更好，因为头文件更有可能使原型正确。

◆ 库文件中包含了函数的编译代码，而头文件中则包含了原型。

◆ 这个过程叫做初始化（initialization）

◆ 但C++与C一样，这两种变体都被称为函数

◆ 在使用之前必须提供其原型，通常把原型放到main( )定义之前

◆ 因此，main( )的返回值并不是返回给程序的其他部分，而是返回给操作系统。

◆ 退出值为0则意味着程序运行成功，为非零则意味着存在问题

◆ 另外，main不是关键字

◆ 参数列表指出了何种信息将被传递给函数，函数类型指出了返回值的类型。

◆ 可以采用另一种方法让两个函数都能够访问名称空间std，即将编译指令放在函数的外面，且位于两个函数的前面

◆ C++提供了两个用于处理输入和输出的预定义对象（cin和cout），它们是istream和ostream类的实例，这两个类是在iostream文件中定义的

◆ cin和cout都是智能对象，能够根据程序上下文自动将信息从一种形式转换为另一种形式。


## 第3章 处理数据

◆ 设计并扩展自己的数据类型

◆ 基本类型和复合类型

◆ 可以使用&运算符来检索braincount的内存地址

◆ 其中每种类型都有符号版本和无符号版本

◆ unsigned long存储不了地球上当前的人数和银河系的星星数，而long long能够

◆ “字节”的含义依赖于实现，因此在一个系统中，两字节的int可能是16位，而在另一个系统中可能是32位

◆ 有些头文件，尤其是那些被设计成可用于C和C++中的头文件，必须使用#define

◆ 在声明变量时对它进行初始化，可避免以后忘记给它赋值的情况发生

◆ 而这正是当前实现中最为常见的行为

◆ int被设置为对目标计算机而言最为“自然”的长度

◆ 如果没有非常有说服力的理由来选择其他类型，则应使用int

◆ 程序将把1492存储为int、long还是其他整型呢？答案是，除非有理由存储为其他类型（如使用了特殊的后缀来表示特定的类型，或者值太大，不能存储为int），否则C++将整型常量存储为int类型

◆ 可以采用任何一种顺序，大写小写均可

◆ cin和cout的行为都是由变量类型引导的

◆ 类ostream有一个put( )成员函数，用来输出字符

◆ 句点被称为成员运算符

◆ 在Release 2.0之后，C++将字符常量存储为char类型，而不是int类型。这意味着cout现在可以正确处理字符常量了

◆ 可替代end

◆ \u后面是8个十六进制位，\U后面则是16个十六进制位

◆ char在默认情况下既不是没有符号，也不是有符号

◆ 显式地将类型设置为signed char 或unsigned char

◆ 如果使用char变量来存储标准ASCII字符，则char有没有符号都没关系，在这种情况下，可以使用char

◆ 这种类型与另一种整型（底层（underlying）类型）的长度和符号属性相同

◆ cin和cout将输入和输出看作是char流

◆ C++将非零值解释为true，将零解释为false

◆ 字面值true和false都可以通过提升转换为int类型，true被转换为1，而false被转换为0

◆ 符号常量—预处理器方法

◆ 如果在声明常量时没有提供值，则该常量的值将是不确定的，且无法修改。

◆ C++内部表示浮点数的方法与此相同，只不过它基于的是二进制数，因此缩放因子是2的幂，不是10的幂

◆ 因此7.2 E6是非法的

◆ float至少32位，double至少48位，且不少于float，long double至少和double一样多

◆ 像8.24和2.4E8这样的浮点常量都属于double类型。如果希望常量为float类型，请使用f或F后缀

◆ 则C++将执行整数除法。这意味着结果的小数部分将被丢弃，使得最后的结果是一个整数

◆ 如果其中有一个（或两个）操作数是浮点值，则小数部分将保留，结果为浮点数

◆ 记住，浮点常量在默认情况下为double类型

◆ 使用相同的符号进行多种操作叫做运算符重载（operator overloading）

◆ C++还允许扩展运算符重载，以便能够用于用户定义的类，因此在这里看到的是一个重要的OOP属性

◆ 将两个short值相加涉及到的硬件编译指令可能会与将两个long值相加不同

◆ 扩展后将得到一个新值，这个值被存储在so_long中，而thirty的内容不变

◆ 因此，有些转换是安全的，有些则会带来麻烦。表3.3列出了一些可能出现的转换问题

◆ 将浮点值赋给整型将导致两个问题。首先，将浮点值转换为整型会将数字截短（除掉小数部分）。其次，float值对于int变量来说可能太大了。在这种情况下，C++并没有定义结果应该是什么；这意味着不同的实现的反应可能不同。

◆ 这导致C++没有对结果进行定义的情况发

◆ C++程序取得chickens和ducks的值，并将它们转换为int。

◆ wchar_t被提升成为下列类型中第一个宽度足够存储wchar_t取值范围的类型

◆ 说明操作数都是整型，因此执行整型提升

◆ 得到的结果取决于何时进行转换。计算auks时，首先将浮点值相加，然后在赋值时，将总数转换为int。但计算bats和coots时，首先通过强制类型转换将浮点值转换为int，然后计算总和

◆ 为此，它重新定义了auto的含义


## 第4章 复合类型

◆ 事实上，可以将数组中的每个元素看作是一个简单变量

◆ 即其中所有的值在编译时都是已知的

◆ 方法是使用下标或索引来对元素进行编号

◆ 如果将一个值赋给不存在的元素months[101]，编译器并不会指出错误

◆ 如果没有初始化函数中定义的数组，则其元素值将是不确定的，这意味着元素的值为以前驻留在该内存单元中的值

◆ 如果将sizeof运算符用于数组名，得到的将是整个数组中的字节数

◆ 则编译器将把其他元素设置为0

◆ 如果初始化数组时方括号内（[ ]）为空，C++编译器将计算元素个数

◆ 列表初始化禁止缩窄转换

◆ 这两个数组都是char数组，但只有第二个数组是字符串

◆ 但尽管如此，还是不应将不是字符串的字符数组当作字符串来处理

◆ 有一种更好的、将字符数组初始化为字符串的方法—只需使用一个用引号括起的字符串即可，这种字符串被称为字符串常量（string constant）或字符串字面值（string literal）

◆ 用引号括起的字符串隐式地包括结尾的空字符，因此不用显式地包括它（参见图4.2）

◆ 各种C++输入工具通过键盘输入，将字符串读入到char数组中时，将自动加上结尾的空字符

◆ 这是因为处理字符串的函数根据空字符的位置，而不是数组长度来进行处理。C++对字符串长度没有限制

◆ 在确定存储字符串所需的最短数组时，别忘了将结尾的空字符计算在内

◆ 更糟糕的是，"S"实际上表示的是字符串所在的内存地址。

◆ 由于地址在C++中是一种独立的类型，因此C++编译器不允许这种不合理的做法（本章后面讨论指针后，将回过头来讨论这个问题）

◆ sizeof运算符指出整个数组的长度

◆ 但strlen( )函数返回的是存储在数组中的字符串的长度，而不是数组本身的长度

◆ trlen( )只计算可见的字符，而不把空字符计算在内

◆ cin使用空白（空格、制表符和换行符）来确定字符串的结束位置

◆ 这把Dreeb留在输入队列中。当cin在输入队列中搜索用户喜欢的甜点时，它发现了Dreeb，因此cin读取Dreeb，并将它放到dessert数组中

◆ 我们必须使用cin的较高级特性

◆ istream中的类（如cin）提供了一些面向行的类成员函数：getline( )和get( )。这两个函数都读取一行输入，直到到达换行符

◆ 该函数有两个参数。第一个参数是用来存储输入行的数组的名称，第二个参数是要读取的字符数。如果这个参数为20，则函数最多读取19个字符，余下的空间用于存储自动在结尾处添加的空字符。getline( )成员函数在读取指定数目的字符或遇到换行符时停止读取

◆ 但get并不再读取并丢弃换行符，而是将其留在输入队列中。假设我们连续两次调用get( )

◆ 果不借助于帮助，get( )将不能跨过该换行符

◆ 之所以可以这样做，是由于cin.get（name，ArSize）返回一个cin对象，该对象随后将被用来调用get( )函数。同样，下面的语句将把输入中连续的两行分别读入到数组name1和name2 中，其效果与两次调用cin.getline( )相同

◆ getline( )使用起来简单一些，但get( )使得检查错误更简单些

◆ 另一个潜在的问题是，输入字符串可能比分配的空间长。如果输入行包含的字符数比指定的多，则getline( )和get( )将把余下的字符留在输入队列中，而getline( )还会设置失效位，并关闭后面的输入。

◆ 当cin读取年份，将回车键生成的换行符留在了输入队列中

◆ 也可以利用表达式cin>>year返回cin对象，将调用拼接起来

◆ string类位于名称空间std中

◆ 可以使用数组表示法来访问存储在string对象中的字符

◆ 可以将string对象声明为简单变量，而不是数组

◆ str1的声明创建一个长度为0的string对象，但程序将输入读取到str1中时，将自动调整str1的长度

◆ 而string类变量是一个表示字符串的实体

◆ string类简化了字符串合并操作。可以使用运算符+将两个string对象合并起来，还可以使用运算符+=将字符串附加到string对象的末尾

◆ 使用字符数组时，总是存在目标数组过小，无法存储指定信息的危险

◆ 在这里，str1是一个string对象，而size( )是string类的一个方法

◆ 首先，为初始化的数组的内容是未定义的

◆ 函数strlen( )从数组的第一个元素开始计算字节数，直到遇到空字符

◆ str中的字符串长度为0。这是因为未被初始化的string对象的长度被自动设置为0

◆ getline( )使用它来避免超越数组的边界。

◆ 这表明这个getline( )不是类方法

◆ 那么，为何一个getline( )是istream的类方法，而另一个不是呢？

◆ 但前面处理string对象的代码使用string类的一个友元函数。有关友元函数及这种技术为何可行，将在第11章介绍。另外，您可以将cin和cout用于string对象，而不用考虑其内部工作原理

◆ 望有一种数据格式可以将所有这些信息存储在一个单元

◆ 结构是一种比数组更灵活的数据格式，因为同一个结构可以存储多种类型的数据，这使得能够将有关篮球运动员的信息放在一个结构中，从而将数据的表示合并到一起

◆ 首先，定义结构描述—它描述并标记了能够存储在结构中的各种数据类型。然后按描述创建结构变量（结构数据对象）。

◆ 则可能已经注意到了，C++允许在声明结构变量时省略关键字struct

◆ 这种变化强调的是，结构声明定义了一种新类型

◆ 顺便说一句，访问类成员函数（如cin.getline( )）的方式是从访问结构成员变量（如vincent.price）的方式衍生而来的。

◆ 另一种选择是将声明放到main( )的前面，这里采用的便是这种方式，位于函数外面的声明被称为外部声明

◆ 外部变量由所有的函数共

◆ C++不提倡使用外部变量，但提倡使用外部结构声明。另外，在外部声明符号常量通常更合理

◆ 使用由逗号分隔值列表，并将这些值用花括号括起

◆ 一定要让结构定义能够访问名称空间std。为此，可以将编译指令using移到结构定义之前；也可以像前面那样，将name的类型声明为std::string。

◆ 还可以使用赋值运算符（=）将结构赋给另一个同类型的结构，这样结构中每个成员都将被设置为另一个结构中相应成员的值，即使成员是数组

◆ 从中可以看出，成员赋值是有效的，因为choice结构的成员值与bouquet结构中存储的值相同

◆ 还可以声明没有名称的结构类型，方法是省略名称，同时定义一种结构类型和一个这种类型的变量

◆ 但这种类型没有名称，因此以后无法创建这种类型的变量

◆ gifts本身是一个数组，而不是结构，因此像gifts.price这样的表述是无效的

◆ 由于guests是一个inflatable数组，因此guests[0]的类型为inflatable，可以使用它和句点运算符来访问相应inflatable结构的成员

◆ 可以使用没有名称的字段来提供间距。每个成员都被称为位字段（bit field）

◆ 因此，pail有时可以是int变量，而有时又可以是double变量。成员名称标识了变量的容量。由于共用体每次只能存储一个值，因此它必须有足够的空间来存储最大的成员，所以，共用体的长度为其最大成员的长度

◆ 匿名共用体（anonymous union）没有名称，其成员将成为位于相同地址处的变量

◆ 由于共用体是匿名的，因此id_num和id_char被视为prize的两个成员，它们的地址相同，所以不需要中间标识符id_val

◆ C++的enum工具提供了另一种创建符号常量的方式

◆ 但将3赋给band将导致类型错误

◆ 非法的原因有些复杂。确实没有为枚举定义运算符+，但用于算术表达式中时，枚举将被转换为整数，因此表达式orange + red将被转换为1 + 0。这是一个合法的表达式，但其类型为int，不能将其赋给类型为spectrum的变量band。

◆ 则可以通过强制类型转换

◆ rst在默认情况下为0。后面没有被初始化的枚举量的值将比其前面的枚举量大1。因此，third的值为101

◆ 其中6不是枚举值，但它位于枚举定义的取值范围内

◆ 另外，在有些系统中，可能不会将这两个变量存储在相邻的内存单元中。

◆ 使用常规变量时，值是指定的量，而地址为派生量

◆ OOP强调的是在运行阶段（而不是编译阶段）进行决策。

◆ 使用OOP时，您可能在运行阶段确定数组的长度

◆ 使用关键字new请求正确数量的内存以及使用指针来跟踪新分配的内存的位置

◆ 处理存储数据的新策略刚好相反，将地址视为指定的量，而将值视为派生量。一种特殊类型的变量—指针用于存储值的地址。因此，指针名表示的是地址。*运算符被称为间接值（indirect velue）或解除引用（dereferencing）运算符，将其应用于指针，可以得到该地址处存储的值（这和乘法使用的符号相同

◆ 我们说p_updates指向int类型，我们还说p_updates的类型是指向int的指针，或int*

◆ 但要知道的是，下面的声明创建一个指针（p1）和一个int变量（p2）

◆ 对每个指针变量名，都需要使用一个*

◆ 在C++中，int *是一种复合类型，是指向int的指针。

◆ 指针变量不仅仅是指针，而且是指向特定类型的指针

◆ 一定要在对指针应用解除引用运算符（*）之前，将指针初始化为一个确定的、适当的地址。这是关于使用指针的金科玉律

◆ 将数字值作为地址来使用，应通过强制类型转换将数字转换为适当的地址类型

◆ 指针真正的用武之地在于，在运行阶段分配未命名的内存以存储值

◆ 并返回该内存块的地址

◆ 它指的是为数据项分配的内存块

◆ 用来指定需要什么样的内存和用来声明合适的指针

◆ 该程序还指出了必须声明指针所指向的类型的原因之一

◆ 它们都是地址，但由于use_new.cpp声明了指针的类型，因此程序知道*pd是8个字节的double值，*pt是4个字节的int值。use_new.cpp打印*pd的值时，cout知道要读取多少字节以及如何解释它们。

◆ 而new从被称为堆（heap）或自由存储区（free store）的内存区域分配内存

◆ 在C++中，值为0的指针被称为空指针（null pointer）。C++确保空指针不会指向有效的数据，因此它常被用来表示运算符或函数失败（如果成功，它们将返回一个有用的指针

◆ 使用delete时，后面要加上指向内存块的指针（这些内存块最初是用new分配的）

◆ 一定要配对地使用new和delete

◆ 如果内存泄漏严重，则程序将由于不断寻找更多内存而终止

◆ 只能用delete来释放使用new分配的内存。然而，对空指针使用delete是安全的。

◆ 一般来说，不要创建两个指向同一个内存块的指针，因为这将增加错误地删除同一个内存块两次的可能性。但稍后您会看到，对于返回指针的函数，使用另一个指针确实有道理。

◆ 通常，对于大型数据（如数组、字符串和结构），应使用new，这正是new的用武之地

◆ 如果通过声明来创建数组，则在程序被编译时将为它分配内存空间。不管程序最终是否使用数组，数组都在那里，它占用了内存

◆ 静态联编（static binding

◆ 被称为动态联编（dynamic binding）

◆ new运算符返回第一个元素的地址。在这个例子中，该地址被赋给指针psome。

◆ 如果使用new [ ]为数组分配内存，则应使用delete [ ]来释放。如果使用new [ ]为一个实体分配内存，则应使用delete（没有方括号）来释放

◆ 可以将它看作是一根指向该元素的手指

◆ C和C++内部都使用指针来处理数组。数组和指针基本等价是C和C++的优点之一（这在有时候也是个问题，但这是另一码事）

◆ 不能修改数组名的值。但指针是变量，因此可以修改它的值。请注意将p3加1的效果。表达式p3[0]现在指的是数组的第2个值。因此，将p3加1导致它指向第2个元素而不是第1个。将它减1后，指针将指向原来的值，这样程序便可以给delete[ ]提供正确的地址。

◆ 但将指针变量加1后，增加的量等于它指向的类型的字节数。将指向double的指针加1后，如果系统对double使用8个字节存储，则数值将增加8；将指向short的指针加1后，如果系统对short使用2个字节存储，则指针值将增加2

◆ C++将数组名解释为数组第1个元素的地址

◆ 现在来看一看数组表达式stacks[1]。C++编译器将该表达式看作是*（stacks + 1），这意味着先计算数组第2个元素的地址，然后找到存储在那里的值。

◆ 区别之一是，可以修改指针的值，而数组名是常量

◆ 对数组应用sizeof运算符得到的是数组的长度，而对指针应用sizeof得到的是指针的长度，即使指针指向的是一个数组

◆ 对数组取地址时，数组名也不会被解释为其地址。等等，数组名难道不被解释为数组的地址吗？不完全如此：数组名被解释为其第一个元素的地址，而对数组名应用地址运算符时，得到的是整个数组的地址：

◆ &tell[0]（即tell）是一个2字节内存块的地址，而&tell是一个20字节内存块的地址

◆ 如果省略括号，优先级规则将使得pas先与[20]结合，导致pas是一个short指针数组，它包含20个元素，因此括号是必不可少的

◆ 一种例外情况是，将sizeof运算符用于数组名用时，此时将返回整个数组的长度（单位为字节）。

◆ 使用数组声明来创建数组时，将采用静态联编

◆ 将采用动态联编（动态数组）

◆ 这里的关键不在于flower是数组名，而在于flower是一个char的地址

◆ 逐个传递字符串中的所有字符相比，这样做的工作量确实要少

◆ 在cout和多数C++表达式中，char数组名、char指针以及用引号括起的字符串常量都被解释为字符串第一个字符的地址

◆ 编译器在内存留出一些空间，以存储程序源代码中所有用引号括起的字符串，并将每个被存储的字符串与其地址关联起来。）这意味着可以像使用字符串“wren”那样使用指针bird，如下面的示例所示：

◆ 字符串字面值是常量，这就是为什么代码在声明中使用关键字const的原因。以这种方式使用const意味着可以用bird来访问字符串，但不能修改它

◆ 创建未初始化的指针有点像签发空头支票：无法控制它将被如何使用

◆ 有些编译器将字符串字面值视为只读常量，如果试图修改它们，将导致运行阶段错误

◆ 则必须将这种指针强制转换为另一种指针类型

◆ 这两个指针将指向相同的内存单元和字符串。

◆ 将animal赋给ps是不可行的，因为这样只能修改存储在ps中的地址，从而失去程序访问新分配内存的唯一途径。

◆ 要避免这种问题，请使用strncpy( )

◆ 这样最多将19个字符复制到数组中，然后将最后一个元素设置成空字符。如果该字符串少于19个字符，则strncpy( )将在复制完该字符串之后加上空字符，以标记该字符串的结尾

◆ 应使用strcpy( )或strncpy( )，而不是赋值运算符来将字符串赋给数组。

◆ 在运行时创建数组优于在编译时创建数组，对于结构也是如此。需要在程序运行时为结构分配所需的空间，这也可以使用new运算符来完成

◆ 这将把足以存储inflatable结构的一块可用内存的地址赋给ps。这种句法和C++的内置类型完全相同

◆ 有时，C++新手在指定结构成员时，搞不清楚何时应使用句点运算符，何时应使用箭头运算符。规则非常简单。如果结构标识符是结构名，则使用句点运算符；如果标识符是指向结构的指针，则使用箭头运算符

◆ 因此（*ps）.price是该结构的price成员

◆ （实际编写程序时，使用string类将更容易，因为这样可以使用内置的new和delete）

◆ 获得空间后，getname( )使用标准库函数strcpy( )将temp中的字符串复制到新的内存块中。

◆ 在函数内部定义的常规变量使用自动存储空间，被称为自动变量（automatic variable）

◆ 自动变量是一个局部变量，其作用域为包含它的代码块

◆ 自动变量通常存储在栈中。这意味着执行代码块时，其中的变量将依次加入到栈中，而在离开代码块时，将按相反的顺序释放这些变量，这被称为后进先出（LIFO）

◆ 静态存储是整个程序执行期间都存在的存储方式。使变量成为静态的方式有两种：一种是在函数外面定义它；另一种是在声明变量时使用关键字static

◆ 自动存储和静态存储的关键在于：这些方法严格地限制了变量的寿命。

◆ new和delete运算符提供了一种比自动变量和静态变量更灵活的方法。它们管理了一个内存池，这在C++中被称为自由存储空间（free store）或堆（heap）

◆ 使用new和delete让程序员对程序如何使用内存有更大的控制权

◆ 但new和delete的相互影响可能导致占用的自由存储区不连续，这使得跟踪新分配内存的位置更困难

◆ 即使包含指针的内存由于作用域规则和对象生命周期的原因而被释放，在自由存储空间上动态分配的变量或结构也将继续存在

◆ C++智能指针有助于自动完成这种任务

◆ 模板类vector类似于string类，也是一种动态数组

◆ 基本上，它是使用new创建动态数组的替代品。实际上，vector类确实使用new和delete来管理内存，但这种工作是自动完成的

◆ 其中参数n_elem可以是整型常量，也可以是整型变量。

◆ vector类的功能比数组强大，但付出的代价是效率稍低

◆ 首先，注意到无论是数组、vector对象还是array对象，都可使用标准数组表示法来访问各个元素

◆ array对象和数组存储在相同的内存区域（即栈）

◆ 注意到可以将一个array对象赋给另一个array对象

◆ 而对于数组，必须逐元素复制数据。

◆ 与C语言一样，C++也不检查这种超界错误。

◆ 中括号表示法和成员函数at()的差别在于，使用at()时，将在运行期间捕获非法索引，而程序默认将中断。这

◆ 如果数据对象是数组，则可以像使用数组名那样使用指针来访问元素；如果数据对象是结构，则可以用指针解除引用运算符（->）来访问其成员。


## 第5章 循环和关系表达式

◆ 另外，常见的做法是缩进for语句体，使它看上去比较显著

◆ 在C++中，每个表达式都有值

◆ C++将赋值表达式的值定义为左侧成员的值，因此这个表达式的值为20

◆ 赋值运算符是从右向左结合的

◆ C++必须将100赋给x。当判定表达式的值这种操作改变了内存中数据的值时，我们说表达式有副作用（side effect）

◆ 因此，判定赋值表达式会带来这样的副作用，即修改被赋值者的值。有可能把赋值看作预期的效果，但从C++的构造方式这个角度来看，判定表达式才是主要作用。

◆ 从表达式到语句的转变很容易，只要加分号即可

◆ 智能编译器甚至可能跳过这条语句

◆ 但int toad并不是表达式，因为它没有值。

◆ 微妙

◆ 这很方便，但并不适用于原来的句法，因为声明不是表达式。

◆ 声明语句表达式

◆ 对于for-init-statement来说，它既可以是表达式语句，也可以是声明。这种句法规则用语句替换了后面跟分号的表达式，语句本身有自己的分

◆ 初始化部分中声明和初始化变量

◆ 通过使用符号常量，就可以避免将所有的10修改为20。

◆ 因此在外部声明ArSize几乎没有任何实际用处，但包含多个函数的程序常常会受益于共享外部常量，因此我们现在就开始练习使用外部变量。

◆ 这个示例使用了using声明，而不是using编译指令。

◆ string类的size( )获得字符串中的字符数

◆ 对这种语句，C++没有定义正确的行为

◆ 首先，副作用（side effect）指的是在计算表达式时对某些东西（如存储在变量中的值）进行了修改；

◆ 在C++中，语句中的分号就是一个顺序点，这意味着程序处理下一条语句之前，赋值运算符、递增运算符和递减运算符执行的所有修改都必须完成。

◆ 在C++11文档中，不再使用术语“顺序点”了，因为这个概念难以用于讨论多线程执行。相反，使用了术语“顺序”，它表示有些事件在其他事件前发生。这种描述方法并非要改变规则，而旨在更清晰地描述多线程编程。

◆ 前缀格式和后缀格式的最终效果相同

◆ 用户这样定义前缀函数：将值加1，然后返回结果；但后缀版本首先复制一个副本，将其加1，然后将复制的副本返回

◆ 总之，对于内置类型，采用哪种格式不会有差别；但对于用户定义的类型，如果有用户定义的递增和递减运算符，则前缀格式的效率更高

◆ 将把指针的值增加其指向的数据类型占用的字节数，这种规则适用于对指针递增和递减

◆ 前缀运算符的从右到到结合规则意味着*++pt的含义如下：现将++应用于pt（因为++位于*的右边），然后将*应用于被递增后的p

◆ 因此*pt++的值为arr[2]，即25.4，但该语句执行完毕后，pt的值将为arr[3]的地址

◆ 方法是用两个花括号来构造一条复合语句（代码块）

◆ 如果在语句块中定义一个新的变量，则仅当程序执行该语句块中的语句时，该变量才存在。执行完该语句块后，变量将被释放。

◆ 逗号运算符对表达式完成同样的任务

◆ 这是因为声明已经将逗号用于其他用途—分隔列表中的变量

◆ 在这种情况下，逗号只是一个列表分隔符，而不是逗号运算符

◆ 这样，temp在每轮循环中都将被分配和释放。这比在循环前声明temp的速度要慢一些。另一方面，如果在循环内部声明temp，则它将在循环结束后被丢弃。

◆ 首先，它确保先计算第一个表达式，然后计算第二个表达式（换句话说，逗号运算符是一个顺序点）。

◆ 逗号表达式的值是第二部分的值

◆ 在所有运算符中，逗号运算符的优先级是最低的

◆ 它能够对值进行比较，这种能力是计算机决策的基础

◆ 如果不小心遗漏了= =运算符中的一个等号，则for循环的测试部分将是一个赋值表达式，而不是关系表达式，此时代码仍是有效的。这是因为可以将任何有效的C++表达式用作for循环的测试条件。

◆ 所以始终为true

◆ 因此很多编译器都会发出警告，询问这是否是设计者的真正意图）

◆ 用引号括起的字符串常量也是其地址

◆ 两个字符串的地址是否相同呢？答案是否定的，虽然它们包含相同的字符。

◆ 应使用C-风格字符串库中的strcmp( )函数来比较

◆ 这意味着两个字符串即使被存储在长度不同的数组中，也可能是相同的：

◆ 但却可以用它们来比较字符，因为字符实际上是整型

◆ 因为类设计让您能够使用关系运算符进行比较

◆ 读者现在只需知道可以将关系运算符用于string对象即可。

◆ tring类重载运算符!=的方式让您能够在下述条件下使用它：至少有一个操作数为string对象，另一个操作数可以是string对象，也可以是C-风格字符串

◆ 在C++中，for和while循环本质上是相同的

◆ 省略for循环中的测试表达式时，测试结果将为true，因此下面的循环将一直运行下去

◆ 如果程序在显示其他内容之前等待5秒钟，情况将会好得多。while循环可用于这种目的。一种用于个人计算机的早期技术是，让计算机进行计数，以等待一段时

◆ 一种是使用预处理器：

◆ 编译程序时

◆ 第二种方法是使用C++（和C）的关键字typedef来创建别名

◆ 可以使用#define，不过声明一系列变量时，这种方法不适用

◆ 使得与使用#define相比，使用typedef是一种更佳的选择—有时候，这也是唯一的选择。

◆ C++11新增了一种循环：基于范围（range-based）的for循环

◆ 读取char值时，与读取其他基本类型一样，cin将忽略空格和换行符。因此输入中的空格没有被回显，也没有被包括在计数内。

◆ 按下回车键后，整个字符序列将被发送给程序，但程序在遇到#字符后将结束对输入的处理。

◆ 该程序回显了每个字符，并将全部字符计算在内，其中包括空格。输入仍被缓冲，因此输入的字符个数仍可能比最终到达程序的要多。

◆ 头文件iostream将cin.get(ch)的参数声明为引用类型，因此该函数可以修改其参数的值

◆ 因为该语言支持被称为函数重载的OOP特性

◆ 则可以使用一种功能更强大的技术—检测文件尾（EOF）

◆ <符号是Unix和Windows命令提示符模式的重定向运算符。

◆ 很多操作系统都允许通过键盘来模拟文件尾条件

◆ cin方法检测到EOF时，将设置cin对象中一个指示EOF条件的标记

◆ cin.clear( )方法可能清除EOF标记

◆ 如果使用cin.get( )来锁住屏幕直到可以阅读它，这将不起作用，因为检测EOF时将禁止进一步读取输入。

◆ 单5.14那样的计时循环来使屏幕停留一段时间

◆ 函数调用cin.get(ch1)返回一个cin对象，然后便可以通过该对象调用get(ch2)

◆ 对于二维数组来说，由于每个元素本身就是一个数组，因此可以使用与上述代码类似的格式来初始化每一个元素

◆ 在这个例子中，可以使用char数组的数组，而不是字符串指针数组

◆ 因此，从存储空间的角度说，使用指针数组更为经济

◆ 在希望字符串是可修改的情况下，string类自动调整大小的特性将使这种方法比使用二维数组更为方便。


## 第6章 分支语句和逻辑运算符

◆ 通常情况下，测试条件都是关系表达式，如那些用来控制循环的表达式

◆ 该程序清单还演示了限定符std::，这是编译指令using的替代品之一。

◆ 然而，很多编译器会发出警告，因此注意警告是明智的

◆ 由于||的优先级比关系运算符低，因此不需要在这些表达式中使用括号

◆ C++规定，||运算符是个顺序点（sequence point）

◆ 另外，如果左侧的表达式为true，则C++将不会去判定右侧的表达式，因为只要一个表达式为true，则整个逻辑表达式为true（读者可能还记得，冒号和逗号运算符也是顺序点）。

◆ 和||运算符一样，&&运算符也是顺序点，因此将首先判定左侧，并且在右侧被判定之前产生所有的副作用。

◆ double类型的精度足以存储典型的int值，且取值范围更大。另一种选择是，使用long long来存储输入的值，因为其取值范围比int大。

◆ 外，它们并不是C语言中的保留字，但C语言程序可以将它们用作运算符，只要在程序中包含了头文件iso646.h。C++不要求使用头文件

◆ 它是C++中唯一一个需要3个操作数的运算符

◆ 则整个表达式的值

◆ 每个标签都必须是整数常量表达式。最常见的标签是int或char常量（如1或'q'），也可以是枚举量

◆ 如果integer-expression不与任何标签匹配，则程序将跳到标签为default的那一行。Default标签是可选的，

◆ C++中的case标签只是行标签，而不是选项之间的界线。也是说，程序跳到switch中特定代码行后，将依次执行之后的所有语句，除非有明确的其他指示。程序不会在执行到下一个case处自动停止，要让程序执行完一组特定语句后停止，必须使用break语句。这将导致程序跳到switch后面的语句处执行。

◆ 通常，cin无法识别枚举类型（它不知道程序员是如何定义它们的），因此该程序要求用户选择选项时输入一个整数。

◆ 将int值和枚举量标签进行比较时，将枚举量提升为int

◆ 也会将枚举量提升为int类型

◆ 另外，这个值必须是整数（包括char

◆ 另外case标签值还必须是常量

◆ switch语句的效率更高。

◆ 虽然continue语句导致该程序跳过循环体的剩余部分，但不会跳过循环的更新表达式

◆ 使用goto语句不好，而应使用结构化控制语句（如if else、switch、continue等）来控制程序的流程。

◆ 非数字输入设置错误标记意味着必须重置该标记，程序才能继续读取输入。clear( )方法重置错误输入标记，同时也重置文件尾（EOF条件，参见第5章）。

◆ 着用cin将输入放到数组中

◆ 重置cin以接受新的输入

◆ 删除错误输入

◆ 提示用户再输入

◆ 该循环的第一条语句使用clear( )方法重置输入，如果省略这条语句，程序将拒绝继续读取输入

◆ 程序在while循环中使用cin.get( )来读取行尾之前的所有输入

◆ 使用cin进行输入时，程序将输入视为一系列的字节，其中每个字节都被解释为字符编码。不管目标数据类型是什么，输入一开始都是字符数据——文本数据。

◆ cin对象负责将文本转换为其他类型

◆ 输入行中的第一个字符被赋给ch。在这里，第一个字符是数字3，其字符编码（二进制）被存储在变量ch中。

◆ 在这种情况下，cin将不断读取，直到遇到非数字字符。也就是说，它将读取3和8，这样句点将成为输入队列中的下一个字符

◆ 在这种情况下，cin将不断读取，直到遇到第一个不属于浮点数的字符。也就是说，cin读取3、8、句点和5，使得空格成为输入队列中的下一个字符

◆ 空字符

◆ 在这种情况下，cin将不断读取，直到遇到换行符（示例输入行少于50个字符）

◆ 换行符被丢弃

◆ 输入一开始为文本。因此，控制台输入的文件版本是文本文件，即每个字节都存储了一个字符编码的文件。

◆ 另外，字处理文件中可能包含文本信息，但也可能包含用于描述格式、字体、打印机等的非文本数据

◆ 下面来复习一些有关将cout用于控制台输出的基本事实，为文件输出做准备

◆ 方法open( )接受一个C-风格字符串作为参数，这可以是一个字面字符串，也可以是存储在数组中的字符串

◆ 声明一个ofstream对象并将其同文件关联起来后，便可以像使用cout那样使用它。所有可用于cout的操作和方法（如<<、endl和setf( )）都可用于ofstream对象（如前述示例中的outFile和fout）。

◆ 声明一个ofstream对象后，便可以使用方法open( )将该对象特定文件关联起来

◆ 创建好ofstream对象（如outFile）后，便可以像使用cout那样使用它

◆ open( )将首先截断该文件，即将其长度截短到零——丢其原有的内容，然后将新的输出加入到该文件中。

◆ 检查文件是否被成功打开至关重

◆ 声明ifstream和ofstream对象，并将它们同文件关联起来后，便可以像使用cin和cout那样使用这些对象


## 第7章 函数——C++的编程模块

◆ 库函数是已经定义和编译好的函数，同时可以使用标准库头文件提供其原型，因此只需正确地调用这种函数即可。

◆ 在每个函数定义中，都使用了一条using编译指令，因为每个函数都使用了cout。另一种方法是，在函数定义之前放置一条using编译指令或在函数中使用std::cout。

◆ 没有返回值的函数被称为void函数

◆ 参数列表int n意味着调用函数cheers( )时，应将一个int值作为参数传递给它。

◆ 是其结果的类型必须为typeName类型或可以被转换为typeName

◆ 不能是数组，但可以是其他任何类型——整数、浮点数、指针，甚至可以是结构和对象

◆ 可以将数组作为结构或对象组成部分来返回

◆ 回函数和调用函数必须就该内存单元中存储的数据的类型达成一致

◆ 函数在执行遇到的第一条返回语句后结束

◆ ，它将函数返回值的类型（如果有的话）以及参数的类型和数量告诉编译器。

◆ C++的编程风格是将main( )放在最前面，因为它通常提供了程序的整体结构。

◆ 函数原型不要求提供变量名，有类型列表就足够了。

◆ 在C++中，括号为空与在括号中使用关键字void是等效的——意味着函数没有参数。

◆ 如果不正确，则转换为正确的类型（如果可能的话）

◆ 原型自动将被传递的参数强制转换为期望的类型。

第8章将介绍的函数重载可能导致二义性，因此不允许某些自动强制类型转换

◆ 仅当有意义时，原型化才会导致类型转换。例如，原型不会将整数转换为结构或指针。

◆ 用于接收传递值的变量被称为形参。传递给函数的值被称为实参。

◆ 在函数结束时，计算机将释放这些变量使用的内存

◆ 则必须分别指定每个参数的类型，而不能像声明常规变量那样，将声明组合在一起

◆ cin.get( )将读取后面的换行符。可以通过编程来避开这种麻烦，但比较简便的方法是像该程序那样使用cin。

◆ 下面来如何将数组和函数结合在一起

◆ 为使函数通用，而不限于特定长度的数组，还需要传递数组长度。这里唯一的新内容是，需要将一个形参声明为数组名。

◆ arr实际上并不是数组，而是一个指针！好消息是，在编写函数的其余部分时，可以将arr看作是数组。

◆ C++将数组名解释为其第一个元素的地址

◆ 该规则有一些例外。首先，数组声明使用数组名来标记存储位置；其次，对数组名使用sizeof将得到整个数组的长度

◆ 这证明这两个函数头都是正确的，因为在C++中，当（且仅当）用于函数头或函数原型中，int *arr和int arr [ ]的含义才是相同的。

◆ 在其他的上下文中，int * arr和int arr [ ]的含义并不相同。例如，不能在函数体中使用int tip[ ]来声明指针。

◆ sum_arr( )函数将cookies的地址赋给指针变量arr，将ArSize赋给int变量n

◆ 程序清单7.5实际上并没有将数组内容传递给函数，而是将数组的位置（地址）、包含的元素种类（类型）以及元素数目（n变量）提交给函数（参见图7.4）。

◆ 传递常规变量时，函数将使用该变量的拷贝；但传递数组时，函数将使用原来的数组。

◆ 但这个值是一个地址，而不是数组的内容。

◆ 数组地址作为参数可以节省复制整个数组所需的时间和内存。

◆ 使用原始数据增加了破坏数据的风险

◆ cookies和arr的值相同。它还演示了指针概念如何使sum_arr函数比以前更通用

◆ 而sizeof arr只是指针变量的长度

◆ 必须显式传递数组长度

◆ 还可以提供假的数组起始位置：

◆ 由于接受数组名参数的函数访问的是原始数组，而不是其副本，因此可以通过调用该函数将值赋给数组元素。

◆ 该函数返回实际读取的元素数

◆ 还有另一个问题——确保显示函数不修改原始数组

◆ 这是由于C++按值传递数据，而且函数使用数据的副本

◆ 这意味着不能使用ar修改该数据，也就是说，可以使用像ar[0]这样的值，但不能修改。

◆ 这并不是意味着原始数组必须是常量，而只是意味着不能在show_array( )函数中使用ar来修改这些数据

◆ 这条消息提醒用户，C++将声明const double ar [ ]解释为const double *ar。因此，该声明实际上是说，ar指向的是一个常量值

◆ 由于这个函数将修改数组的值，因此在声明ar时，不能使用const。

◆ lboud + 20指向数组结尾后面的一个位置。将区间传递给函数将告诉函数应处理哪些元素。

◆ 第一种方法是让指针指向一个常量对象，这样可以防止使用该指针来修改所指向的值，第二种方法是将指针本身声明为常量，这样可以防止改变指针指向的位置。

◆ 该声明指出，pt指向一个const int（这里为39），因此不能使用pt来修改这个值。

◆ pt的声明并不意味着它指向的值实际上就是一个常量

◆ C++禁止第二种情况的原因很简单——如果将g_moon的地址赋给pm，则可以使用pm来修改g_moon的值，这使得g_moon的const状态很荒谬，因此C++禁止将const的地址赋给非const指针

◆ 假设有一个由const数据组成的数组：

◆ 禁止将常量数组的地址赋给非常量指针将意味着不能将数组名作为参数传递给使用非常量形参的函数：

◆ 但仍然不能使用pt来修改它指向的值（现在为80）。

◆ 这种声明格式使得finger只能指向sloth，但允许使用finger来修改sloth的值。

◆ 但允许将ps指向另一个位置。简而言之，finger和*ps都是const，而*finger和ps不是

◆ const的指针来保护数据

◆ 只要只有一层间接关系，就可以使用这种技术。例如，这里的数组元素是基本类型，但如果它们是指针或指向指针的指针，则不能使用const。

◆ 比较难处理的是如何正确地声明指针

◆ 4个指向int的指针组成的数组

◆ 它指向由4个int组成的数组。因此，指针类型指定了列数，这就是没有将列数作为独立的函数参数进行传递的原因。

◆ 由于指针类型指定了列数，因此sum( )函数只能接受由4列组成的数组

◆ 必须对指针ar2执行两次解除引用，才能得到数据。最简单的方法是使用方括号两次：ar2[r][c]。然而，如果不考虑难看的话，也可以使用运算符*两次：

◆ 将字符串作为参数时意味着传递的是地址，但可以使用const来禁止对字符串参数进行修改。

◆ 被设置为字符串的地址的char指针。

◆ 但实际传递的是字符串第一个字符的地址

◆ 字符串有内置的结束字符

◆ 这意味着不必将字符串长度作为参数传递给函数

◆ 不应

◆ 参数不一定必须是数组名，也可以是其他形式的指针

◆ str将指向结尾的空值字符，使得*str等于0——空值字符的数字编码，从而结束循环。

◆ 函数无法返回一个字符串，但可以返回字符串的地址，这样做的效率更高。

◆ 需要能够存储n + 1个字符的空间，以便能够存储空值字符

◆ pstr（而不是字符串）使用的内存将被释放。

◆ delete释放

◆ 读者将知道C++类如何使用构造函数和析构函数负责为您处理这些细节。

◆ 但在涉及到函数时，结构变量的行为更接近于基本的单值变量。

◆ 结构将其数据组合成单个实体或数据对象，该实体被视为一个整体

◆ 函数将使用原始结构的副本

◆ 使用结构编程时，最直接的方式是像处理基本类型那样来处理结构；也就是说，将结构作为参数传递，并在需要时将结构用作返回值使用。

◆ 按值传递结构有一个缺点。如果结构非常大，则复制结构将增加内存要求，降低系统运行的速度

◆ 许多C程序员倾向于传递结构的地址

◆ C++提供了第三种选择——按引用传递

◆ 距离和角度一起构成了极坐标

◆ 该函数接受一个rect参数，并返回一个polar结构

◆ 有些编译器仅当被明确指示后，才会搜索数学库

◆ 另外请记住，非数字输入将设置一个错误条件，禁止进一步读取输入。如果程序在输入循环后还需要进行输入，则必须使用cin.clear( )重置输入，然后还可能需要通过读取不合法的输入来丢弃它们

◆ string对象与结构的更相似

◆ 可以将一个结构赋给另一个结构，也可以将一个对象赋给另一个对

◆ 可以将结构作为完整的实体传递给函数，也可以将对象作为完整的实体进行传递。如果需要多个字符串，可以声明一个string对象数组

◆ 该程序像对待内置类型（如int）一样对待string对象。

◆ 在C++中，类对象是基于结构的，因此结构编程方面的有些考虑因素也适用于类。

◆ 函数处理的是原始对象的副本

◆ 模板array并非只能存储基本数据类型，它还可存储类对象

◆ std::限定array和string

◆ 函数fill()使用指针来直接处理原始对象，这避免了上述效率低下的问题

◆ 因此*pa为这种对象，而(*pa) [i]是该对象的一个元素。

◆ 运算符优先级的影响，其中的括号必不可少

◆ 然而，与C语言不同的是，C++不允许main( )调用自己

◆ 每个递归调用都创建自己的一套变量

◆ 函数的地址是存储其机器语言代码的内存的开始地址

◆ 为实现这种目标，采用的机制是，将程序员要使用的算法函数的地址传递给estimate( )

◆ 要将函数作为参数进行传递，必须传递函数名

◆ 一定要区分传递的是函数的地址还是函数的返回值

◆ 声明指向某种数据类型的指针时，必须指定指针指向的类型

◆ 这意味着声明应指定函数的返回类型以及函数的特征标

◆ 由于pam是函数，因此（*pf）也是函数。而如果（*pf）是函数，则pf就是函数指针。

◆ 正确地声明pf后，便可以将相应函数的地址赋给它：

◆ 函数指针的表示可能非常恐怖。下面通过一个示例演示使用函数指针时面临的一些挑战。首先，下面是一些函数的原型，它们的特征标和返回类型相同：

◆ 另一方面，函数定义必须提供标识符，因此需要使用const double ar [ ]或const double * ar

◆ 使用C++11的自动类型推断功能时，代码要简单得多

◆ 因此，pa是一个包含三个指针的数组，其中每个指针都指向这样的函数，即将const double *和int作为参数，并返回一个const double *。

◆ 自动类型推断只能用于单值初始化，而不能用于初始化列表

◆ 自动类型推断功能表明，编译器的角色发生了改变

◆ 自动类型推断确保变量的类型与赋给它的初值的类型一致

◆ 函数是C++的编程模块。要使用函数，必须提供定义和原型，并调用该函数。函数定义是实现函数功能的代码；

◆ string类的方法size( )可用于判断其存储的字符串的长度

◆ 这意味着可以按值传递结构，并将其用作函数返回类型。然而，如果结构非常大，则传递结构指针的效率将更高，同时函数能够使用原始数据。这些考虑因素也适用于类对象


## 第8章 函数探幽

◆ 新特性包括内联函数、按引用传递变量、默认的参数值、函数重载（多态）以及模板函数

◆ 内联函数是C++为提高程序运行速度所做的一项改进

◆ C++编译器如何将它们组合到程序中

◆ 来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销。

◆ 内联函数的编译代码与其他程序代码“内联”起来了。也就是说，编译器将使用相应的函数代码替换函数调用

◆ 内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。如果程序在10个不同的地方调用同一个内联函数，则该程序将包含该函数代码的10个副本

◆ 将整个定义（即函数头和所有函数代码）放在本应提供原型的地方。

◆ 内联函数不能递归

◆ 这使得C++的内联功能远远胜过C语言的宏定义

◆ 而是要指出，如果使用C语言的宏执行了类似函数的功能，应考虑将它们转换为C++内联函数

◆ 引用是已定义的变量的别名（另一个名称）

◆ 但引用变量的主要用途是用作函数的形参。

◆ 这样除指针之外，引用也为函数处理大型结构提供了一种非常方便的途径，同时对于设计类来说，引用也是必不可少的。

◆ 语句中的&运算符不是地址运算符，而是将rodents的类型声明为int &，即指向int变量的引用

◆ 将rodents加1将影响这两个变量。更准确地说，rodents++操作将一个有两个名称的变量加1。

◆ 差别之一是，必须在声明引用时将其初始化，而不能像指针那样，先声明，再赋值

◆ 引用更接近const指针，必须在创建时进行初始化，一旦与某个变量关联起来，就将一直效忠于它。

◆ 简而言之，可以通过初始化声明来设置引用，但不能通过赋值来设置

◆ 将rodents初始化为*pt使得rodents指向rats。接下来将pt改为指向bunnies，并不能改变这样的事实，即rodents引用的是rats

◆ 引用经常被用作函数参数，使得函数中的变量名成为调用程序中的变量的别名。这种传递参数的方法称为按引用传递

◆ 2024/03/21发表想法

本质上，依然是按值传递

原文：C语言只能按值传递。按值传递导致被调用函数使用调用程序的值的拷贝（参见图8.2）。当然，C语言也允许避开按值传递的限制，采用按指针传递的方式。

◆ C语言只能按值传递。按值传递导致被调用函数使用调用程序的值的拷贝（参见图8.2）。当然，C语言也允许避开按值传递的限制，采用按指针传递的方式。

◆ 这意味着按值传递变量将不管用，因为函数将交换原始变量副本的内容，而不是变量本身的内容。

◆ 另一个区别是指针版本需要在函数使用p和q的整个过程中使用解除引用运算符*。

◆ 函数调用使用实参初始化形参，因此函数的引用参数被初始化为函数调用传递的实参

◆ refcube( )函数修改了main( )中的x值，而cube( )没有，这提醒我们为何通常按值传递。

◆ 如果程序员的意图是让函数使用传递给它的信息，而不对这些信息进行修改，同时又想使用引用，则应使用常量引用

◆ 编译器发现代码修改了ra的值时，将生成错误消息。

◆ 如果要编写类似于上述示例的函数（即使用基本数值类型），应采用按值传递的方式，而不要采用按引用传递的方式。当数据比较大（如结构和类）时，引用参数将很有用

◆ 按值传递的函数

◆ 在现代的C++中，这是错误的，大多数编译器都将指出这一点；而有些较老的编译器将发出这样的警告

◆ 由于x + 3.0不是double类型的变量，因此程序将创建一个临时的无名变量，并将其初始化为表达式x + 3.0的值

◆ 然后，ra将成为该临时变量的引用

◆ 如果实参与引用参数不匹配，C++将生成临时变量

◆ 则编译器将在下面两种情况下生成临时变量：实参的类型正确，但不是左值；实参的类型不正确，但可以转换为正确的类型。

◆ 左值参数是可被引用的数据对象，例如，变量、数组元素、结构成员、引用和解除引用的指针都是左值。

◆ 常规变量和const变量都可视为左值，因为可通过地址访问它们。但常规变量属于可修改的左值，而const变量属于不可修改的左值。

◆ 另一方面，参数7.0和side + 10.0的类型都正确，但没有名称，在这些情况下，编译器都将生成一个临时匿名变量，并让ra指向它。这些临时变量只在函数调用期间存在，此后编译器便可以随意将其删除。

◆ 这里的类型不匹配，因此编译器将创建两个临时int变量，将它们初始化为3和5，然后交换临时变量的内容，而a和b保持不变

◆ 简而言之，如果接受引用参数的函数的意图是修改作为参数传递的变量，则创建临时变量将阻止这种意图的实现。

◆ 如果函数调用的参数不是左值或与相应的const引用参数的类型不匹配，则C++将创建类型正确的匿名变量，将函数调用的参数的值传递给该匿名变量，并让参数来引用该变量。

◆ 使用const使函数能够处理const和非const实参，否则将只能接受非const数据；

◆ 使用const引用使函数能够正确生成并使用临时变量。

◆ 因此，应尽可能将引用形参声明为const。

◆ C++11新增了另一种引用——右值引用（rvalue reference）。这种引用可指向右值，是使用&&声明的：

◆ 引用非常适合用于结构和类（C++的用户定义类型）。确实，引入引用主要是为了用于这些类型的，而不是基本的内置类型。

◆ 如果返回类型被声明为free_throws而不是free_throws &，上述返回语句将返回target（也就是team）的拷贝。但返回类型为引用，这意味着返回的是最初传递给accumulate()的team对象。

◆ 在第一条语句中，值4.0被复制到一个临时位置，然后被复制给m

◆ 如果accumulate()返回一个结构，而不是指向结构的引用，将把整个结构复制到一个临时位置，再将这个拷贝复制给dup。但在返回值为引用时，将直接把team复制到dup，其效率更高。

◆ 返回引用时最重要的一点是，应避免返回函数终止时不再存在的内存单元引用

◆ 该函数返回一个指向临时变量（newguy）的引用，函数运行完毕后它将不再存在。

◆ 第9章 将讨论各种变量的持续性。同样，也应避免返回指向临时变量的指针。

◆ 返回一个作为参数传递给函数的引用

◆ 作为参数的引用将指向调用函数使用的数据，因此返回的引用也将指向这些数据。

◆ 另一种方法是用new来分配新的存储空间。

◆ 也就是说，在赋值表达式中，左边的子表达式必须标识一个可修改的内存块。在这里，函数返回指向dup的引用，它确实标识的是一个这样的内存块，因此这条语句是合法的。

◆ 但为何常规函数返回值是右值呢？这是因为这种返回值位于临时内存单元中，运行到下一条语句时，它们可能不再存在。

◆ 假设您要使用引用返回值，但又不允许执行像给accumulate()赋值这样的操作，只需将返回类型声明为const引用：

◆ 现在返回类型为const，是不可修改的左值，因此下面的赋值语句不合法：

◆ 另外，您仍可以在赋值语句右边使用accumulate()。

◆ 创建一个函数，它将指定的字符串加入到另一个字符串的前面和后面

◆ 然而其中的一个存在非常大的缺陷，可能导致程序崩溃甚至不同通过编译。

◆ 这两个函数参数都是const引用。如果使用string对象作为参数，最终结果将不变

◆ 因此该函数的返回类型为string，这意味着temp的内容将被复制到一个临时存储单元中

◆ 假设实参的类型与引用参数类型不匹配，但可被转换为引用类型，程序将创建一个正确类型的临时变量，使用转换后的实参值来初始化它，然后传递一个指向该临时变量的引用。

◆ 该函数可以修改s1，因为不同于s2，s1没有被声明为const。

◆ 这个函数能够通过编译（但编译器会发出警告），但当程序试图执行该函数时将崩溃。

◆ 程序试图引用已经释放的内存。

◆ 使得能够将特性从一个类传递给另一个类的语言特性被称为继承，

◆ 派生类继承了基类的方法，这意味着ofstream对象可以使用基类的特性，如格式化方法precision( )和setf( )。

◆ 基类引用可以指向派生类对象

◆ 这种特征的一个实际结果是，可以定义一个接受基类引用作为参数的函数，调用该函数时，可以将基类对象作为参数，也可以将派生类对象作为参数。

◆ setf(ios_base::showpoint)将对象置于显示小数点的模式，即使小数部分为零。

◆ 方法setf( )返回调用它之前有效的所有格式化设置

◆ 程序员能够修改调用函数中的数据对象。通过传递引用而不是整个数据对象，可以提高程序的运行速度。

◆ 如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针。

◆ 如果数据对象是结构，则使用引用或指针。如果数据对象是类对象，则使用引用。

◆ 函数调用left(“theory”, 3)将创建新字符串“the”，并返回一个指向该字符串的指针

◆ 但函数调用left(“theory”)不会出错，它认为第二个参数的值为1，并返回指向字符串“t”的指针。

◆ 对于带参数列表的函数，必须从右向左添加默认值。

◆ 要为某个参数设置默认值，则必须为它右边的所有参数提供默认值：

◆ 实参按从左到右的顺序依次被赋给相应的形参，而不能跳过任何参数。

◆ 在设计类时您将发现，通过使用默认参数，可以减少要定义的析构函数、方法以及方法重载的数量。

◆ 只有原型指定了默认值。函数定义与没有默认参数时完全相同。

◆ 默认参数让您能够使用不同数目的参数调用同一个函数，而函数多态（函数重载）让您能够使用多个同名的函数

◆ 可以通过函数重载来设计一系列函数——它们完成相同的工作，但使用不同的参数列表。

◆ 函数重载的关键是函数的参数列表——也称为函数特征标（function signature）。

◆ 条件是它们的特征标不同

◆ 没有匹配的原型并不会自动停止使用其中的某个函数，因为C++将尝试使用标准类型转换强制进行匹配

◆ 如果#2原型是print( )唯一的原型，则函数调用print(year, 6)将把year转换为double类型。

◆ 有3个将数字作为第一个参数的原型，因此有3种转换year的方式。在这种情况下，C++将拒绝这种函数调用，并将其视为错误。

◆ 为避免这种混乱，编译器在检查函数特征标时，将把类型引用和类型本身视为同一个特征标

◆ dribble( )函数有两个原型，一个用于const指针，另一个用于常规指针，编译器将根据实参是否为const来决定使用哪个原型

◆ 而drivel( )函数可以与带const或非const参数的调用匹配

◆ 主要是由于将非const值赋给const变量是合法的，但反之则是非法的。

◆ 请记住，是特征标，而不是函数类型使得可以对函数进行重载

◆ 返回类型可以不同，但特征标也必须不同：

◆ 右值

◆ 如果没有定义函数stove(double &&)，stove(x+y)将调用函数stove(const double &)。

◆ 下面添加另一个left()函数，它返回整数的前n位

◆ 仅当函数基本上执行相同的任务，但使用不同形式的数据时，才应采用函数重载。

◆ C++编译器将执行一些神奇的操作——名称修饰（name decoration）或名称矫正（name mangling）

◆ 它根据函数原型中指定的形参类型对每个函数名进行加密

◆ 函数模板是通用的函数描述，也就是说，它们使用泛型来定义函数，其中的泛型可用具体的类型（如int或double）替换

◆ 通过将类型作为参数传递给模板，可使编译器生成该类型的函数

◆ 由于类型是用参数表示的，因此模板特性有时也被称为参数化类型（parameterized types）

◆ 假设要交换两个double值，则一种方法是复制原来的代码，并用double替换所有的int。如果需要交换两个char值，可以再次使用同样的技术。进行这种修改将浪费宝贵的时间，且容易出错

◆ 第一行指出，要建立一个模板，并将类型命名为AnyType。关键字template和typename是必需的，除非可以使用关键字class代替typename。

◆ 模板并不创建任何函数，而只是告诉编译器如何定义函数

◆ 然而，有大量代码库是使用关键字class开发的。在这种上下文中，这两个关键字是等价的。本书使用了这两种形式，旨在让您在其他地方遇到它们时不会感到陌生。

◆ 如果需要多个将同一种算法用于不同类型的函数，请使用模板

◆ 在文件的开始位置提供模板函数的原型，并在main( )后面提供模板函数的定义。

◆ 第一个Swap( )函数接受两个int参数，因此编译器生成该函数的int版本。也就是说，用int替换所有的T，生成下面这样的定义

◆ 程序员看不到这些代码，但编译器确实生成并在程序中使用了它们

◆ 函数模板不能缩短可执行程序。对于程序清单8.11，最终仍将由两个独立的函数定义，就像以手工方式定义了这些函数一样。最终的代码不包含任何模板，而只包含了为程序生成的实际函数

◆ 为满足这种需求，可以像重载常规函数定义那样重载模板定义

◆ 和常规重载一样，被重载的模板的函数特征标必须不同

◆ 原来的模板的特征标为(T &, T &)，而新模板的特征标为(T [ ], T [ ],int)。注意，在后一个模板中，最后一个参数的类型为具体类型（int），而不是泛型。并非所有的模板参数都必须是模板参数类型。

◆ 但第二次调用将两个int数组和一个int值用作参数，这与新模板匹配。

◆ 代码假定可执行哪些操作。例如，下面的代码假定定义了赋值，但如果T为数组，这种假设将不成立

◆ 总之，编写的模板函数很可能无法处理某些类型。另一方面，有时候通用化是有意义的，但C++语法不允许这样做。

◆ C++允许您重载运算符+，以便能够将其用于特定的结构或类

◆ 可以提供一个具体化函数定义——称为显式具体化

◆ 对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数以及它们的重载版本。

◆ 具体化优先于常规模板，而非模板函数优先于具体化和常规模板。

◆ Swap<job>中的<job>是可选的

◆ 编译器使用模板为特定类型生成函数定义时，得到的是模板实例（instantiation

◆ 板并非函数定义，但使用int的模板实例是函数定义。

◆ 显式实例化（explicit instantiation）

◆ 将使用Swap( )模板生成一个使用int类型的实例。也就是说，该声明的意思是“使用Swap( )模板生成int类型的函数定义

◆ 显式具体化使用下面两个等价的声明之一

◆ 式具体化声明在关键字template后包含<>，而显式实例化没有

◆ 使用函数来创建显式实例化

◆ 但通过使用Add<double>(x, m)，可强制为double类型实例化，并将参数m强制转换为double类型，以便与函数Add<double>(double, double)的第二个参数匹配。

◆ 对于函数重载、函数模板和函数模板重载，C++需要（且有）一个定义良好的策略，来决定为函数调用使用哪一个函数定义，尤其是有多个参数时。这个过程称为重载解析（overloading resolution）

◆ 注意，只考虑特征标，而不考虑返回类型。其中的两个候选函数（#4和#7）不可行，因为整数类型不能被隐式地转换（即没有显式强制类型转换）为指针类型。

◆ 什么是完全匹配？如果两个函数（如#3和#5）都完全匹配，将如何办呢？通常，有两个函数完全匹配是一种错误，但这一规则有两个例外。

◆ 正如您预期的，如果有多个匹配的原型，则编译器将无法完成重载解析过程；如果没有最佳的可行函数，则编译器将生成一条错误消息，该消息可能会使用诸如“ambiguous（二义性）”这样的词语。

◆ 如果只定义了函数#3和#4是完全匹配的，则将选择#3，因为ink没有被声明为const。

◆ const和非const之间的区别只适用于指针和引用指向的数据。也就是说，如果只定义了#1和#2，则将出现二义性错

◆ 也就是说，#2模板已经显式指出，函数参数是指向Type的指针，因此可以直接用blot标识Type

◆ Type已经被具体化为指针，因此说它“更具体”。

◆ 如果将模板B从程序中删除，则编译器将使用模板A来显示pd的内容，因此显示的将是地址，而不是值。

◆ 常规函数一样，通过在使用函数前提供模板函数定义，它让它也充当原型。

◆ 编译器应选择模板函数，而不是非模板函数

◆ x和y的值将被强制转换为int，该函数返回一个int值，

◆ 在C++98中，编写模板函数时，一个问题是并非总能知道应在声明中使用哪种类型。

◆ C++11新增的关键字decltype提供了解决方案。可这样使用该关键字

◆ decltype提供的参数可以是表达式，因此在前面的模板函数ft()中

◆ decltype比这些示例演示的要复杂些。为确定类型，编译器必须遍历一个核对表

◆ 如果expression是一个函数调用，则var的类型与函数的返回类型相同

◆ 并不会实际调用函数。编译器通过查看函数的原型来获悉返回类型，而无需实际调用函数。

◆ 如果expression是一个左值，则var为指向其类型的引用

◆ 一种显而易见的情况是，expression是用括号括起的标识符

◆ 请注意，虽然k和n都是引用，但表达式k+n不是引用；它是两个int的和，因此类型为int

◆ auto是一个占位符，表示后置返回类型提供的类型，这是C++11给auto新增的一种角色。这种语法也可用于函数定义

◆ 现在，decltype在参数声明后面，因此x和y位于作用域内，可以使用它们。

◆ 编译器不是让程序跳到独立的代码段，以执行函数，而是用相应的代码替换函数调用。只有在函数很短时才能采用内联方式

◆ 引用变量是一种伪装指针，它允许为变量创建别名（另一个名称）。引用变量主要被用作处理结构和类对象的函数的参数

◆ 只能在参数列表中从右到左提供默认参数。

◆ 则必须为该参数右边所有的参数提供默认值。

◆ 函数的特征标是其参数列表。程序员可以定义两个同名函数，只要其特征标不同。这被称为函数多态或函数重载。通常，通过重载函数来为不同的数据类型提供相同的服务。

◆ 编译器将为程序中使用的特定参数类型生成正确的函数定义


## 第9章 内存模型和名称空间

◆ C++为在内存中存储数据方面提供了多种选择。可以选择数据保留在内存中的时间长度（存储持续性）以及程序的哪一部分可以访问数据（作用域和链接）等

◆ 和C语言一样，C++也允许甚至鼓励程序员将组件函数放在独立的文件中。

◆ 一个文件（头文件）包含了用户定义类型的定义；另一个文件包含操纵用户定义类型的函数的代码

◆ 请不要将函数定义或变量声明放到头文件中。这样做对于简单的情况可能是可行的，但通常会引来麻烦。

◆ 如果在头文件包含一个函数定义，然后在其他两个文件（属于同一个程序）中包含该头文件，则同一个程序中将包含同一个函数的两个定义，除非函数是内联的，否则这将出错。

◆ 被声明为const的数据和内联函数有特殊的链接属性（稍后将介绍），因此可以将其放在头文件中，而不会引起问题

◆ 如果文件名包含在尖括号中，则C++编译器将在存储标准头文件的主机系统的文件系统中查找；但如果文件名包含在双引号中，则编译器将首先查找当前的工作目录或源代码目录（或其他目录，这取决于编译器）。

◆ 另外，不要使用#include来包含源代码文件，这样做将导致多重声明。

◆ 在同一个文件中只能将同一个头文件包含一次。

◆ 下面的代码片段意味着仅当以前没有使用预处理器编译指令#define定义名称COORDINH 时，才处理#ifndef和#endif之间的语句

◆ 这种方法并不能防止编译器将文件包含两次，而只是让它忽略除第一次包含之外的所有内容。

◆ 两个编译器将为同一个函数生成不同的修饰名称

◆ 在链接编译模块时，请确保所有对象文件或库都是由同一个编译器生成的。如果有源代码，通常可以用自己的编译器重新编译源代码来消除链接错误。

◆ 这些方案的区别就在于数据保留在内存中的时间

◆ 静态存储持续性：在函数定义外定义的变量和使用关键字static定义的变量的存储持续性都为静态

◆ 如果变量是使用关键字thread_local声明的，则其生命周期与所属的线程一样长

◆ 用new运算符分配的内存将一直存在，直到使用delete运算符将其释放或程序结束为止。

◆ 链接性（linkage）描述了名称如何在不同单元间共享

◆ 链接性为外部的名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共享

◆ 静态变量的作用域是全局还是局部取决于它是如何被定义的

◆ 在名称空间中声明的变量的作用域为整个名称空间（由于名称空间已经引入到C++语言中，因此全局作用域是名称空间作用域的特例）。

◆ 常用的方法是留出一段内存，并将其视为栈，以管理变量的增减。

◆ 关键字register最初是由C语言引入的，它建议编译器使用CPU寄存器来存储自动变量：

◆ 在C++11中，这种提示作用也失去了，关键字register只是显式地指出变量是自动的。

◆ 外部链接性

◆ 内部链接性

◆ 无链接性

◆ 这3种链接性都在整个程序执行期间存在，与自动变量相比，它们的寿命更长

◆ 编译器将分配固定的内存块来存储所有的静态变量，这些变量在整个程序执行期间一直存在

◆ 如果没有显式地初始化静态变量，编译器将把它设置为0。在默认情况下，静态数组和结构将每个元素或成员的所有位都设置为0。

◆ 要想创建链接性为外部的静态持续变量，必须在代码块的外面声明它

◆ 要创建链接性为内部的静态持续变量，必须在代码块的外面声明它，并使用static限定符

◆ 要创建没有链接性的静态持续变量，必须在代码块内声明它，并使用static限定符。

◆ 与llama不同的是，即使在funct1( )函数没有被执行时，count也留在内存中

◆ 由于global的链接性为外部，因此可以在程序的其他文件中使用它。

◆ 所有的静态持续变量都有下述初始化特征：未被初始化的静态变量的所有位都被设置为0。这种变量被称为零初始化的（zero-initialized）。

◆ 零初始化和常量表达式初始化被统称为静态初始化，这意味着在编译器处理文件（翻译单元）时初始化变量。动态初始化意味着变量将在编译后初始化。

◆ 首先，所有静态变量都被零初始化，而不管程序员是否显式地初始化了它。

◆ 首先，x、y、z和pi被零初始化。然后，编译器计算常量表达式，并将y和z分别初始化为5和169。但要初始化pi，必须调用函数atan()，这需要等到该函数被链接且程序执行时。

◆ 常量表达式并非只能是使用字面常量的算术表达式。例如，它还可使用sizeof运算符

◆ 一种是定义声明（defining declaration）或简称为定义（definition），它给变量分配存储空间；另一种是引用声明（referencing declaration）或简称为声明（declaration），它不给变量分配存储空间，因为它引用已有的变量

◆ 关键字extern并非必不可少的，因为即使省略它，效果也相同

◆ 这种声明将被视为一个自动变量的定义，当程序执行自动变量所属的函数时，该变量将位于作用域内。

◆ main( )和update( )都可以访问外部变量warming。注意，update( )修改了warming，这种修改在随后使用该变量时显现出来了。

◆ 函数update()使用关键字extern重新声明了变量warming，这个关键字的意思是，通过这个名称使用在外部定义的变量。由于即使省略该声明，update( )的功能也相同，因此该声明是可选的。它指出该函数被设计成使用外部变量。

◆ C++比C语言更进了一步——它提供了作用域解析运算符（::）

◆ 放在变量名前面时，该运算符表示使用变量的全局版本。

◆ 全局变量很有吸引力——因为所有的函数能访问全局变量，因此不用传递参数。

◆ 可以让多个函数可以使用同一个数据块（如月份名数组或原子量数组）。外部存储尤其适于表示常量数据，因为这样可以使用关键字const来防止数据被修改。

◆ 第一个const防止字符串被修改，第二个const确保数组中每个指针始终指向它最初指向的字符串

◆ 将static限定符用于作用域为整个文件的变量时，该变量的链接性将为内部的

◆ 但常规外部变量都具有外部链接性，即可以在其他文件中使用

◆ 但如果文件定义了一个静态外部变量，其名称与另一个文件中声明的常规外部变量相同，则在该文件中，静态变量将隐藏常规外部变量

◆ 这没有违反单定义规则，因为关键字static指出标识符errors的链接性为内部

◆ 使用该变量的其他文件必须使用关键字extern声明它

◆ 可使用外部变量在多文件程序的不同部分之间共享数据；可使用链接性为内部的静态变量在同一个文件中的多个函数之间共享数据

◆ 如果将作用域为整个文件的变量变为静态的，就不必担心其名称与其他文件中的作用域为整个文件的变量发生冲突。

◆ 无链接性的局部变量。这种变量是这样创建的，将static限定符用于在代码块中定义的变量。在代码块中使用static时，将导致局部变量的存储持续性为静态的。

◆ 但它在该代码块不处于活动状态时仍然存在

◆ 存储说明符

◆ 但在C++11中，auto用于自动类型推断。关键字register用于在声明中指示寄存器存储，而在C++11中，它只是显式地指出变量是自动的

◆ 关键字extern表明是引用声明，即声明引用在其他地方定义的变量

◆ 关键字thread_local指出变量的持续性与其所属线程的持续性相同。thread_local变量之于线程，犹如常规静态变量之于整个程序

◆ 它表明，内存被初始化后，程序便不能再对它进行修改。

◆ 该关键字的作用是为了改善编译器的优化能力

◆ 2024/03/25发表想法

这说明这个 volatile 关键字发挥了它的作用。其实不只是内嵌汇编操纵栈"这种方式属于编译无法识别的变量改变，另外更多的可能是多线程并发访问共享变量时，一个线程改变了变量的值，怎样让改变后的值对其它线程 visible。

原文：将变量声明为volatile，相当于告诉编译器，不要进行这种优化。

◆ 将变量声明为volatile，相当于告诉编译器，不要进行这种优化。

◆ 现在回到mutable。可以用它来指出，即使结构（或类）变量为const，其某个成员也可以被修改。

◆ veep的const限定符禁止程序修改veep的成员，但access成员的mutable说明符使得access不受这种限制。

◆ 但const全局变量的链接性为内部的。也就是说，在C++看来，全局const定义（如下述代码段所示）就像使用了static说明符一样

◆ 假设将一组常量放在头文件中，并在同一个程序的多个文件中使用该头文件。那么，预处理器将头文件的内容包含到每个源文件中后，所有的源文件都将包含类似下面这样的定义

◆ 要为某个文件使用一组定义，而其他文件使用另一组声明

◆ 内部链接性还意味着，每个文件都有自己的一组常量，而不是所有文件共享一组常量

◆ 这样，只要在两个源代码文件中包括同一个头文件，则它们将获得同一组常量。

◆ 则可以使用extern关键字来覆盖默认的内部链接性

◆ 定义常规外部变量时，不必使用extern关键字

◆ 和C语言一样，C++不允许在一个函数中定义另外一个函数，因此所有函数的存储持续性都自动为静态的，即在整个程序执行期间都一直存在。

◆ 要让程序在另一个文件中查找函数，该文件必须作为程序的组成部分被编译，或者是由链接程序搜索的库文件

◆ 使之只能在一个文件中使用。必须同时在原型和函数定义中使用该关键字

◆ 这意味着该函数只在这个文件中可见，还意味着可以在其他文件中定义同名的的函数。和变量一样，在定义静态函数的文件中，静态函数将覆盖外部定义，因此即使在外部定义了同名的函数，该文件仍将使用静态函数。

◆ 但使用该函数的每个文件都应包含其函数原型。

◆ 这意味着如果定义了一个与库函数同名的函数，编译器将使用程序员定义的版本，而不是库函数

◆ 链接程序要求每个不同的函数都有不同的符号名

◆ 为满足内部需要，C语言编译器可能将spiff这样的函数名翻译为_spiff。这种方法被称为C语言链接性（C language linkage）

◆ 这种方法被称为C++语言链接（C++ language linkage）

◆ 第4章介绍过，动态内存由运算符new和delete控制，而不是由作用域和链接性规则控制。

◆ 编译器使用三块独立的内存：一块用于静态变量（可能再细分），一块用于自动变量，另外一块用于动态存储

◆ 如果希望另一个函数能够使用这80个字节中的内容，则必须将其地址传递或返回给该函数。

◆ 由new分配的内存通常都将被释放，不过情况也并不总是这样

◆ 最佳的做法是，使用delete来释放new分配的内存。

◆ 这种括号语法也可用于有合适构造函数的类

◆ 这些函数被称为分配函数（alloction function），它们位于全局名称空间中。

◆ new运算符还有另一种变体，被称为定位（placement）new运算符，它让您能够指定要使用的位置。

◆ 要使用定位new特性，首先需要包含头文件new，它提供了这种版本的new运算符的原型

◆ 上述代码从buffer1中分配空间给结构chaff，从buffer2中分配空间给一个包含20个元素的int数组。

◆ 定位new运算符使用传递给它的地址，它不跟踪哪些内存单元已被使用，也不查找未使用的内存块。

◆ 而delete只能用于这样的指针：指向常规new运算符分配的堆内存。

◆ 如果buffer是使用常规new运算符创建的，便可以使用常规delete运算符来释放整个内存块

◆ 基本上，它只是返回传递给它的地址，并将其强制转换为void *，以便能够赋给任何指针类型。

◆ 变量、函数、结构、枚举、类以及类和结构的成员

◆ 用户可能希望使用一个库的List类，而使用另一个库的Tree类。这种冲突被称为名称空间问题。

◆ 先复习一下C++中已有的名称空间属性，并介绍一些术语，让读者熟悉名称空间的概念

◆ 声明区域

◆ 可以在函数外面声明全局变量，对于这种变量，其声明区域为其声明所在的文件

◆ 从声明点开始，到其声明区域的结尾

◆ C++关于全局变量和局部变量的规则定义了一种名称空间层次

◆ C++新增了这样一种功能，即通过定义一种新的声明区域来创建命名的名称空间，这样做的目的之一是提供一个声明名称的区域。

◆ 名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中。因此，在默认情况下，在名称空间中声明的名称的链接性为外部的

◆ 全局名称空间（global namespace）

◆ 名称空间是开放的（open），即可以把名称加入到已有的名称空间中。

◆ 未被装饰的名称（如pail）称为未限定的名称（unqualified name）；包含名称空间的名称（如Jack::pail）称为限定的名称（qualified name

◆ using声明使特定的标识符可用，using编译指令使整个名称空间可用。

◆ using声明将特定的名称添加到它所属的声明区域中。

◆ 由于using声明将名称添加到局部声明区域中，因此这个示例避免了将另一个局部变量也命名为fetch。

◆ 在函数的外面使用using声明时，将把名称添加到全局名称空间中：

◆ using声明使一个名称可用，而using编译指令使所有的名称都可用。

◆ 它使名称空间中的所有名称都可用，而不需要使用作用域解析运算符：

◆ 如果有名称空间jack和jill，并在代码中使用作用域解析运算符，则不会存在二义性

◆ 编译器不允许您同时使用上述两个using声明，因为这将导致二义性

◆ 使用using编译指令导入一个名称空间中所有的名称与使用多个using声明是不一样的，而更像是大量使用作用域解析运算符

◆ 使用using编译指令时，将进行名称解析，就像在包含using声明和名称空间本身的最小声明区域中声明了名称一样。

◆ 如果使用using编译指令导入一个已经在函数中声明的名称，则局部名称将隐藏名称空间名，就像隐藏同名的全局变量一样。

◆ 一般说来，使用using声明比使用using编译指令更安全，这是由于它只导入指定的名称。如果该名称与局部名称发生冲突，编译器将发出指示

◆ 名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。

◆ 这将名称空间std中的所有内容导出到全局名称空间中。

◆ 由于Jill::fetch现在位于名称空间myth（在这里，它被叫做fetch）中，因此可以这样访问它

◆ using编译指令是可传递的。如果A op B且B op C，则A op C，则说操作op是可传递的

◆ 可以使用这种技术来简化对嵌套名称空间的使用：

◆ 在该名称空间中声明的名称的潜在作用域为：从声明点到该声明区域末尾

◆ debts名称空间也包含一些原型。

◆ 因此定义和声明必须位于同一个名称空间中

◆ 通过包含namesp.h（参见程序清单9.11）导入了原来的名称空间。然后该文件将函数定义添加入到两个名称空间中

◆ 如果函数被重载，则一个using声明将导入所有的版本

◆ another( )函数使用using声明和作用域解析运算符来访问具体的名称

◆ 使用在已命名的名称空间中声明的变量，而不是使用外部全局变量。

◆ 使用在已命名的名称空间中声明的变量，而不是使用静态全局变量。

◆ C++当前提倡将标准函数库放在名称空间std中，这种做法扩展到了来自C语言中的函数

◆ 对于using声明，首选将其作用域设置为局部而不是全局。

◆ 使用头文件来定义用户类型，为操纵用户类型的函数提供函数原型

◆ 并将函数定义放在一个独立的源代码文件中

◆ 将main( )和其他使用这些函数的函数放在第三个文件中。

◆ 没有使用说明符时，变量将默认为自动的

◆ 使用extern且不初始化

◆ 但使用关键字static限定的函数的链接性为内部的，被限制在定义它的文件中。

◆ 可以通过使用作用域解析运算符、using声明或using编译指令，来使名称空间中的标识符可用。


## 第10章 对象和类

◆ 面向对象编程（OOP）是一种特殊的、设计程序的概念性方法，C++通过一些特性改进了C语言，使得应用这种方法更容易。

◆ 抽象；封装和数据隐藏；多态；继承；代码的可重用性。

◆ 特殊

◆ 运算符重载（另一种多态）和继承，它们是代码重用的基础。

◆ 首先从用户的角度考虑对象——描述对象所需的数据以及描述用户与数据交互所需的操作。

◆ 将问题的本质特征抽象出来，并根据特征来描述解决方案

◆ 因此，将变量声明为int或float指针时，不仅仅是分配内存，还规定了可对变量执行的操作

◆ 决定数据对象需要的内存数量；

◆ 决定如何解释内存中的位（long和float在内存中占用的位数相同，但将它们转换为数值的方法不同）；

◆ 决定可使用数据对象执行的操作或方法。

◆ 对于内置类型来说，有关操作的信息被内置到编译器中。但在C++中定义用户自定义的类型时，必须自己提供这些信息。付出这些劳动换来了根据实际需要定制新数据类型的强大功能和灵活性。

◆ 它将数据表示和操纵数据的方法组合成一个整洁的包

◆ 类声明：以数据成员的方式描述数据部分

◆ 以成员函数（被称为方法）的方式描述公有接口

◆ 简单地说，类声明提供了类的蓝图，而方法定义则提供了细节。

◆ 接口是一个共享框架，供两个系统（如在计算机和打印机之间或者用户或计算机程序之间）交互时使用

◆ 类设计禁止公共用户直接访问类，但公众可以使用方法size( )

◆ C++程序员将接口（类定义）放在头文件中，并将实现（类方法的代码）放在源代码文件中

◆ 使用类对象的程序都可以直接访问公有部分

◆ 类设计尽可能将公有接口与实现细节分开

◆ 数据隐藏（将数据放在类的私有部分中）是一种封装，将实现的细节隐藏在私有部分中，就像Stock类对set_tot( )所做的那样，也是一种封装。封装的另一个例子是，将类函数定义和类声明放在不同的文件中。

◆ main( )函数只需定义这个结构类型的变量

◆ 使得数据只能被授权的函数访问

◆ 但由于隐藏数据是OOP主要的目标之一，因此数据项通常放在私有部分，组成类接口的成员函数放在公有部分

◆ 不必在类声明中使用关键字private，因为这是类对象的默认访问控制

◆ 作用域解析运算符

◆ 作用域解析运算符确定了方法定义对应的类的身份

◆ 而，在类声明和方法定义之外使用update( )时，需要采取特殊的措施，稍后将作介绍

◆ 它只能在类作用域中使用

◆ 编译器禁止这样做

◆ 其定义位于类声明中的函数都将自动成为内联函数，因此Stock::set_tot( )是一个内联函数。类声明常将短小的成员函数作为内联函数，set_tot( )符合这样的要求。

◆ 如果愿意，也可以在类声明之外定义成员函数，并使其成为内联函数。

◆ 内联函数的特殊规则要求在每个使用它们的文件中都对其进行定义

◆ 在OOP中，调用成员函数被称为发送消息

◆ OOP程序员常依照客户/服务器模型来讨论程序设计

◆ 这意味着客户（客户程序员）唯一的责任是了解该接口

◆ 指定类设计的第一步是提供类声明

◆ 声明有私有部分，在其中声明的成员只能通过成员函数进行访问

◆ 成员函数被放在公有部分中

◆ C++通过类使得实现抽象、数据隐藏和封装等OOP特性很容易。

◆ 单独提供函数定义（除非函数很小

◆ 名称Retort的作用域为整个类，因此在类声明和类方法之外使用该名称时，需要使用作用域解析运算符进行限定。

◆ 应为类提供被称为构造函数和析构函数的标准函数

◆ 不能像上面这样初始化Stock对象的原因在于，数据部分的访问状态是私有的，这意味着程序不能直接访问数据成员。

◆ 因此需要设计合适的成员函数，才能成功地将对象初始化

◆ 但使数据成为公有的违背了类的一个主要初衷：数据隐藏

◆ 一般来说，最好是在创建对象时对它进行初始化

◆ 类构造函数，专门用于构造新对象、将值赋给它们的数据成员

◆ C++为这些成员函数提供了名称和使用语法，而程序员需要提供方法定义。名称与类名相同

◆ 构造函数的原型和函数头有一个有趣的特征——虽然没有返回值，但没有被声明为void类型。实际上，构造函数没有声明类型

◆ （第4个值，total_val成员，是根据shares和share_val计算得到的，因此不必为构造函数提供这个值。）

◆ 这是错误的。构造函数的参数表示的不是类成员，而是赋给类成员的值。因此，参数名不能与类成员相同，否则最终的代码将是这样的

◆ 两种使用构造函数来初始化对象的方式

◆ 每次创建类对象（甚至使用new动态分配内存）时，C++都使用类构造函数。

◆ 对象没有名称，但可以使用指针来管理该对象

◆ 默认构造函数是在未提供显式初始值时，用来创建对象的构造函数

◆ 当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数

◆ 如果提供了非默认构造函数（如Stock(const char *co, int n, double pr)），但没有提供默认构造函数，则下面的声明将出错

◆ 另一种方式是通过函数重载来定义另一个构造函数——一个没有参数的构造函数

◆ 通常应提供对所有类成员做隐式初始化的默认构造函数。

◆ 隐式地调用默认构造函数时，不要使用圆括号

◆ 对象过期时，程序将自动调用一个特殊的成员函数，该函数的名称令人生畏——析构函数

◆ delete来释放这些内存

◆ 析构函数也可以没有返回值和声明类型

◆ 析构函数没有参数

◆ 原型

◆ 因此可以将它编写为不执行任何操作的函数

◆ 如果创建的是静态存储类对象，则其析构函数将在程序结束时自动被调用。如果创建的是自动存储类对象（就像前面的示例中那样），则其析构函数将在程序执行完代码块时（该对象是在其中定义的）自动被调用

◆ 当使用delete来释放内存时，其析构函数将自动被调用

◆ 如果没有这些大括号，代码块将为整个main()，因此仅当main()执行完毕后，才会调用析构函数

◆ 另一种方式是允许调用构造函数来创建一个临时对象，然后将该临时对象复制到stock2中，并丢弃它。如果编译器使用的是这种方式，则将为临时对象调用析构函数，因此生成下面的输出

◆ 这是通过让构造程序创建一个新的、临时的对象

◆ 第一条语句是初始化，它创建有指定值的对象，可能会创建临时对象（也可能不会）；第二条语句是赋值。像这样在赋值语句中使用构造函数总会导致在赋值前创建一个临时对象。

◆ 只要提供与某个构造函数的参数列表匹配的内容，并用大括号将它们括起

◆ 因为show( )的代码无法确保调用对象不被修改——调用对象和const一样，不应被修改

◆ 需要一种新的语法——保证函数不会修改调用对象。

◆ 就像应尽可能将const引用和指针用作函数形参一样，只要类方法不修改调用对象，就应将其声明为const。从现在开始，我们将遵守这一规则。

◆ 接受一个参数的构造函数允许使用赋值语法将对象初始化为一个值：[插图]这种特性可能导致问题，但正如第11章将介绍的，可关闭这项特性。

◆ 否则，必须自己提供默认构造函数。

◆ 但有时候方法可能涉及到两个对象，在这种情况下需要使用C++的this指针。

◆ topval( )方法使用一个类型为const Stock &的参数。

◆ 该函数不会修改被隐式地访问的对象

◆ 更为清晰。可以使用运算符重载（参见第11章）完成这项工作

◆ 使用被称为this的特殊指针。this指针指向用来调用成员函数的对象（this被作为隐藏参数传递给方法）

◆ 置为stock2对象的地址。一般来说，所有的类方法都将this指针设置为调用它的对象的地址

◆ 每个成员函数（包括构造函数和析构函数）都有一个this指针。this指针指向调用对象。

◆ *this

◆ 要返回的并不是this，因为this是对象的地址，而是对象本身，即*this

◆ 在这种情况下，将使用不执行任何操作的隐式默认构造函数），要么定义了一个显式默认构造函数（就像这个例子那样）

◆ 如果类包含多个构造函数，则可以对不同的元素使用不同的构造函数

◆ 由于该声明只初始化了数组的部分元素，因此余下的7个元素将使用默认构造函数进行初始化。

◆ 初始化对象数组的方案是，首先使用默认构造函数创建数组元素，然后花括号中的构造函数将创建临时对象，然后将临时对象的内容复制到相应的元素中。

◆ 定义成员函数时，必须使用作用域解析运算符

◆ 因此创建一个由所有对象共享的常量是个不错的主意

◆ C++11提供了成员初始化，但不适用于前述数组声明

◆ 这将创建一个名为Months的常量，该常量将与其他静态变量存储在一起，而不是存储在对象中。因此，只有一个Months常量，被所有Bakery对象共享

◆ 这将无法通过编译，因为egg Small和t_shirt Small位于相同的作用域内，它们将发生冲突。为避免这种问题，C++11提供了一种新枚举，其枚举量的作用域为类。

◆ 也可使用关键字struct代替class。无论使用哪种方式，都需要使用枚举名来限定枚举量：

◆ 使用OOP方法解决编程问题的第一步是根据它与程序之间的接口来描述数据，从而指定如何使用数据。

◆ 类声明（包括由函数原型表示的方法）应放到头文件中。

◆ 类是用户定义的类型，对象是类的实例

◆ 由于this指针被设置为调用对象的地址，因此*this是该对象的别名。


## 第11章 使用类

◆ 本章将进一步探讨类的特征，重点是类设计技术，而不是通用原理。

◆ 运算符重载

◆ 然后介绍友元，这种C++机制使得非成员函数可以访问私有数据。

◆ 这被称为函数重载或函数多态，旨在让您能够用同名的函数来完成相同的基本操作

◆ C++允许将运算符重载扩展到用户定义的类型，例如，允许使用+将两个对象相加。编译器将根据操作数的数目和类型决定使用哪种加法定义。重载运算符可使代码看起来更自然。

◆ 这种简单的加法表示法隐藏了内部机理，并强调了实质，这是OOP的另一个目标。

◆ op必须是有效的C++运算符，不能虚构一个新的符号

◆ 现在将其推广，采用一个使用方法来处理加法的Time类。

◆ 但由于sum对象是局部变量，在函数结束时将被删除，因此引用将指向一个不存在的对象

◆ 总之，最后的返回值为t1、t2和t3之和，这正是我们期望的

◆ 重载的运算符（有些例外情况）不必是成员函数，但必须至少有一个操作数是用户定义的类型。

◆ [插图]

◆ C++控制对类对象私有部分的访问。通常，公有类方法提供唯一的访问途径，但是有时候这种限制太严格，以致于不适合特定的编程问题。在这种情况下，C++提供了另外一种形式的访问权限：友元

◆ 通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。

◆ 记住，左侧的操作数是调用对象

◆ ，编译器不能使用成员函数调用来替换该表达式。

◆ 非成员函数不是由对象调用的，它使用的所有值（包括对象）都是显式参数。

◆ 与下面的非成员函数调用匹配

◆ 对于非成员重载运算符函数来说，运算符表达式左边的操作数对应于运算符函数的第一个参数，运算符表达式右边的操作数对应于运算符函数的第二个参数。而原来的成员函数则按相反的顺序处理操作数，也就是说，double值乘以Time值。

◆ 2024/03/27发表想法

这是定死的


原文：对于非成员重载运算符函数来说，运算符表达式左边的操作数对应于运算符函数的第一个参数，运算符表达式右边的操作数对应于运算符函数的第二个参数。而原来的成员函数则按相反的顺序处理操作数，也就是说，double值乘以Time值。

◆ 非成员函数不能直接访问类的私有数据，至少常规非成员函数不能访问。然而，有一类特殊的非成员函数可以访问类的私有成员，它们被称为友元函数

◆ 虽然operator *( )函数是在类声明中声明的，但它不是成员函数，因此不能使用成员运算符来调用；虽然operator *( )函数不是成员函数，但它与成员函数的访问权限相同。

◆ 类的友元函数是非成员函数，其访问权限与成员函数相同。

◆ 通过使用友元函数和类方法，可以用同一个用户接口表达这两种操作。

◆ 只有类声明可以决定哪一个函数是友元，因此类声明仍然控制了哪些函数可以访问私有数据。总之，类方法和友元只是表达类接口的两种不同机制。

◆ 按下面的方式对定义进行修改（交换乘法操作数的顺序），可以将这个友元函数编写为非友元函数

◆ 个版本将Time对象t作为一个整体使用，让成员函数来处理私有值，因此不必是友元。然而，将该版本作为友元也是一个好主意。

◆ 其次，如果以后发现需要函数直接访问私有数据，则只要修改函数定义即可，而不必修改类原型。

◆ 如果要为类重载运算符，并将非类的项作为其第一个操作数，则可以用友元函数来反转操作数的顺序。

◆ 可以对<<运算符进行重载，使之能与cout一起来显示对象的内容。

◆ 之所以可以这样做，是因为<<是可被重载的C++运算符之一。

◆ 这是因为对于每种基本类型，ostream类声明中都包含了相应的重载的operator<<( )定义。

◆ 看看函数代码就会发现，尽管该函数访问了Time对象的各个成员，但从始至终都将ostream对象作为一个整体使用

◆ 但由于它并不直接访问ostream对象的私有成员，所以并不一定必须是ostream类的友元

◆ 但这种实现不允许像通常那样将重新定义的<<运算符与cout一起使用

◆ 正如iosream中定义的那样，<<运算符要求左边是一个ostream对象

◆ 其中包括operator*( )和operator<<( )这两个友元函数。它将第一个友元函数作为内联函数，因为其代码很短。

◆ 只有在类声明中的原型中才能使用friend关键字。除非函数定义也是原型，否则不能在函数定义中使用该关键字

◆ 一般来说，非成员函数应是友元函数，这样它才能直接访问类的私有数据。

◆ 对于友元版本来说，两个操作数都作为参数来传递。

◆ 非成员版本的重载运算符函数所需的形参数目与运算符使用的操作数数目相同；而成员版本所需的参数数目少一个，因为其中的一个操作数是被隐式地传递的调用对象。

◆ 因为这两种格式都与同一个表达式匹配，同时定义这两种格式将被视为二义性错误，导致编译错误

◆ 像下面这样的调用无法通过编译，因为诸如2等整数不能隐式地转换为枚举类型

◆ 这正是重载的乘法运算符要完成的工作

◆ 可以像Time示例那样，使用一个内联友元函数来处理double与Vector相乘

◆ 这意味着将从隐式矢量参数减去以显式参数传递的矢量

◆ operator-( )有两种不同的定义。这是可行的，因为它们的特征标不同。可以定义−运算符的一元和二元版本，因为C++提供了该运算符的一元和二元版本。

◆ 下面介绍类的另一个主题——类型转换。

◆ 将一个标准类型变量的值赋给另一种标准类型的变量时，如果这两种类型兼容，则C++自动将这个值转换为接收变量的类型。

◆ 上述赋值语句都是可行的，因为在C++看来，各种数值类型都表示相同的东西——一个数字，同时C++包含用于进行转换的内置规则。

